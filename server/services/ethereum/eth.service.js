'use strict'

var Q = require('q');

var debug = require('debug')('Contracts');
var mongoose = require('mongoose');
var path = require('path');
var fs = require('fs');
var web3 = require('web3');

var Contract = require('../../api/contract/contract.model');
var ContractInstance
			 = require('../../api/contractInstance/contractInstance.model');

function initWeb3() {
	web3.setProvider(new web3.providers.HttpProvider("http://localhost:8545"));
}

function prepareForTransaction(acc, secret) {
	secret = secret || 'secret';

	var unlock = web3.personal.unlockAccount(acc, 'secret');
	if (!web3.eth.mining) {
		web3.miner.start(1);
	}

	return unlock;
}

var EthService = {
	listAccounts: function () {
		var accounts = web3.eth.accounts;
		var accountsData = [];
		for (var key in accounts) {
			var account = accounts[key];
			var base = web3.eth.coinbase;
			accountsData.push({ address: account, balance: web3.fromWei(web3.eth.getBalance(account), 'ether'), isBase: account === base });
		}

		return accountsData;
	},

	processContractSource: function (fileData) {
		// { fieldname: 'file', originalname: 'robots.txt', encoding: '7bit', mimetype: 'text/plain', destination: 'uploads/', 
		//   filename: 'da96e132f4f5050f7a37658d48b9f4dd', path: 'uploads/da96e132f4f5050f7a37658d48b9f4dd', size: 31 }
		var contractName = fileData.originalname;
		var sourceFile = path.normalize(__dirname + '/../../../' + fileData.path);

		var deferred = Q.defer();

		fs.readFile(sourceFile, 'utf8', function (err, data) {
			if (err) {
				deferred.reject(err);
			}

			debug('file: ' + data);
			var compiled = web3.eth.compile.solidity(data);
			debug(compiled);

			deferred.resolve(compiled);
			fs.unlink(sourceFile);
		});

		debug(contractName);
		debug(sourceFile);
		
		return deferred;
	},

	createContract: function (contractId, params) {

		if (!params) {
			params = [];
		}

		var deferred = Q.defer();
		
		Contract.findOneQ({ _id: mongoose.Types.ObjectId(contractId) }).then(function (contract) {
			// let's assume that coinbase is our account
			var acc = web3.eth.coinbase;
			web3.eth.defaultAccount = acc;
		
			// XXX: hardcoded contract name!!
			var code = contract.code;
			// contract json abi, this is autogenerated using solc CLI
			
			try {
				var abi = JSON.parse(contract.abi);
				var unlock = prepareForTransaction(acc);
				if (unlock) {
					var estimate = web3.eth.estimateGas({ from: acc, data: code });
					web3.eth.contract(abi).new({ data: code, gas: estimate * 2 }, function (err, contract) {
						if (err) {
							debug(err);
							
							deferred.reject(err);							
							return deferred;
							// callback fires twice, we only want the second call when the contract is deployed
						} else if (contract.address) {
							ContractInstance.createQ({
								address: contract.address,
								transactionHash: contract.transactionHash,
								contractId: contractId
							}).then(function (contractInstance) {
								deferred.resolve(contractInstance);
							});
						}
					});
				}
			} catch (err) {
				debug(err);
				deferred.reject(err);
			}
		}, function (err) {
			deferred.reject(err);
		});
		
		return deferred;
	},
};

initWeb3();

module.exports = EthService;