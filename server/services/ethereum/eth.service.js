'use strict'

var Q = require('q');

var debug = require('debug')('Contracts');
var mongoose = require('mongoose');
var path = require('path');
var fs = require('fs');
var web3 = require('web3');

var Contract = require('../../api/contract/contract.model');
var ContractInstance
			 = require('../../api/contractInstance/contractInstance.model');

function initWeb3() {
	web3.setProvider(new web3.providers.HttpProvider("http://localhost:8545"));
}

/**
 * Prepares for an account needed operation (mostly transactions), unlocks acc with secret.
 * Optional, provide callback for async call. (web3 like).
 */
function prepareForTransaction(acc, secret, callback) {
	secret = secret || 'secret';
	var threads = 1;

	if (!callback) {
		if (acc === 'base') {
			acc = web3.eth.coinbase;
		}
		
		// sync implementation
		var unlock = web3.personal.unlockAccount(acc, secret);
		if (!web3.eth.mining) {
			web3.miner.start(threads);
		}

		return unlock;
	} else {
		var asyncUnlock = function (web3Error, acc) {
			if (!web3Error) {
				// async unlock account
				web3.personal.unlockAccount(acc, secret, function (web3Error, unlock) {
					if (!web3Error && unlock) { // if unlock was a success
						// then async check mining
						web3.eth.getMining(function (web3Error, mining) {
							if (!web3Error) {
								if (!mining) {
									// if not mining, async start the miners
									web3.miner.start(threads, callback);
								} else {
									// miners already running, just callback
									callback(false, true);
								}
							} else {
								callback(web3Error, false);
							}
						});
					} else {
						callback(web3Error, false);
					}
				});
			} else {
				callback(web3Error, false);
			}
		}

		if (acc === 'base') {
			web3.eth.getCoinbase(asyncUnlock);
		} else {
			asyncUnlock(false, acc);
		}
	}
}

var EthService = {
	listAccounts: function () {
		var accounts = web3.eth.accounts;
		var accountsData = [];
		for (var key in accounts) {
			var account = accounts[key];
			var base = web3.eth.coinbase;
			accountsData.push({ address: account, balance: web3.fromWei(web3.eth.getBalance(account), 'ether'), isBase: account === base });
		}

		return accountsData;
	},

	processContractSource: function (sourceCode) {
		// { fieldname: 'file', originalname: 'robots.txt', encoding: '7bit', mimetype: 'text/plain', destination: 'uploads/', 
		//   filename: 'da96e132f4f5050f7a37658d48b9f4dd', path: 'uploads/da96e132f4f5050f7a37658d48b9f4dd', size: 31 }
		var deferred = Q.defer();

		debug('file: ' + sourceCode);
		var compiled = web3.eth.compile.solidity(sourceCode);
		debug(compiled);

		deferred.resolve(compiled);

		return deferred.promise;
	},

	createContractQ: function (contractId, params) {

		if (!params) {
			params = [];
		}

		var deferred = Q.defer();

		Contract.findOneQ({ _id: mongoose.Types.ObjectId(contractId) }).then(function (contract) {
			// let's assume that coinbase is our account
			var acc = web3.eth.coinbase;
			web3.eth.defaultAccount = acc;
		
			// XXX: hardcoded contract name!!
			var code = contract.code;
			// contract json abi, this is autogenerated using solc CLI
			
			try {
				var abi = JSON.parse(contract.abi);
				var unlock = prepareForTransaction(acc);
				if (unlock) {
					var estimate = web3.eth.estimateGas({ from: acc, data: code });
					web3.eth.contract(abi).new({ data: code, gas: estimate * 2 }, function (err, contract) {
						if (err) {
							debug(err);

							deferred.reject(err);
							return deferred.promise;
							// callback fires twice, we only want the second call when the contract is deployed
						} else if (contract.address) {
							// contract is now mined
							ContractInstance.updateQ({
								transactionHash: contract.transactionHash,
							}, {
								mined: true, 
								address: contract.address
							}).done();
						} else {
							
							// contract submitted, but not mined
							ContractInstance.createQ({
								transactionHash: contract.transactionHash,
								contractId: contractId,
								mined: false
							}).then(function (contractInstance) {
								deferred.resolve(contractInstance);
							});
						}
					});
				}
			} catch (err) {
				debug(err);
				deferred.reject(err);
			}
		}, function (err) {
			deferred.reject(err);
		});

		return deferred.promise;
	},

	/**
	 * Calls a method belonging to an instance with the specified params.
	 * Does not call constructors!
	 * Returns a promise. 
	 */

	callContractMethodQ: function (instanceId, methodName, callParams) {

		// this returns a promise
		var deferred = Q.defer();

		// reject function
		var errorHandle = function (err) {
			deferred.reject(err);
		};

		// process params in a way we can handle them
		var callParamsArray = [];
		for (var param in callParams) {
			callParamsArray.push(callParams[param]);
		}

		var instancePromise = ContractInstance.findOneQ({ _id: mongoose.Types.ObjectId(instanceId) });

		// promise we get the instance from the db first
		instancePromise.then(function (instance) {
			
			// promise for the contract abi, to use later
			var contractPromise = Contract.findOneQ({ _id: mongoose.Types.ObjectId(instance.contractId) });

			// async get the instance status from the blockchain via geth
			web3.eth.getCode(instance.address, function (web3Error, code) {
				if (!web3Error) { // if geth is online
					if (code == "0x") {
						// this instance commited suicide
						errorHandle("This contract commited suicide, you have to move on.");
						return;
					} else {
						//promise we get the contract abi from the db first
						contractPromise.then(function (contract) {
							try {
								var foundMethod = false;
								var abiParsed = JSON.parse(contract.abi);
								// search for the method inside the abi
								for (var key in abiParsed) {
									var abiElement = abiParsed[key];
									if (abiElement.type === 'function' && abiElement.name === methodName) {
										foundMethod = {
											isMethodConstant: abiElement.constant,
										};
									}
								}

								if (foundMethod) {
									//do web3 operations
									
									//unlock account first
									prepareForTransaction('base', false, function (web3Error, unlock) {

										if (!web3Error && unlock) {
											// get the contract obj async
											web3.eth.contract(abiParsed).at(instance.address, function (web3Error, contractObj) {

												if (!web3Error) {
													if (foundMethod.isMethodConstant) { // if method is constant, we just call it directly
														var call = contractObj[methodName];

														callParamsArray.push(function (web3Error, response) {
															deferred.resolve({
																isMethodConstant: true,
																message: response
															});
														});
														call.apply(contractObj, callParamsArray);
													} else {
														// if method is not constant we do a dry call for the return value and 
														// a transaction to call the method on the blockchain
														var dryCall = contractObj[methodName];

														var dryCallParams = callParamsArray.slice(0); //clone
														dryCallParams.push(function (web3Error, dryCallResponse) {
															// this executes after dry call arrives
															if (!web3Error) {
																var call = contractObj[methodName].sendTransaction;
																callParamsArray.push({ from: web3.eth.coinbase });
																callParamsArray.push(function (web3Error, txHashResponse) {
																	// this executes after the final call is received
													
																	if (!web3Error) {
																		deferred.resolve({
																			isMethodConstant: false,
																			txHash: txHashResponse,
																			message: dryCallResponse
																		});
																	} else {
																		errorHandle(web3Error);
																	}
																});
																// get the final call async
																call.apply(contractObj, callParamsArray);
															} else {
																errorHandle(web3Error);
															}
														});
														//get the dry call async
														dryCall.call.apply(contractObj, dryCallParams);
													}
												} else {
													errorHandle(web3Error);
												}
											});
										} else if (web3Error) {
											errorHandle(web3Error);
										} else {
											errorHandle('Can\'t unlock account');
										}
									});
								} else {
									// method does not exist
									errorHandle('Method ' + methodName + ' does not exist!');
								}
							} catch (err) {
								errorHandle(err);
							}
						}, errorHandle);
					}
				} else {
					errorHandle(web3Error);
				}
			});
		}, errorHandle);

		return deferred.promise;
	}
};

initWeb3();

module.exports = EthService;